import { apiUrl } from "../socket";
import { peersPath } from "./data";

const secretParamName = "secret";
const multiaddressParamName = "multiaddress";

export function getUrlToShare(secret: string, multiaddress: string): string {
  const baseUrl = new URL(apiUrl);
  baseUrl.pathname = peersPath;
  baseUrl.searchParams.set(secretParamName, secret);
  baseUrl.searchParams.set(multiaddressParamName, multiaddress);
  return baseUrl.toString();
}

export function parseUrlToShare(
  urlSearch: string
): { secret: string | null; multiaddress: string | null } {
  const queryParams = new URLSearchParams(urlSearch);
  const secret = queryParams.get(secretParamName);
  const multiaddress = queryParams.get(multiaddressParamName);
  return { secret, multiaddress };
}

export function getRandomHex(bytes: number): string {
  const array = window.crypto.getRandomValues(new Uint8Array(bytes));
  return Array.from(array)
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");
}

export function getBootstrapMultiaddress({
  staticIp,
  domain,
  port,
  peerId
}: {
  staticIp?: string;
  domain?: string;
  port: number;
  peerId: string;
}): string {
  if (!port) throw Error(`port must be defined`);
  if (!peerId) throw Error(`peerId must be defined`);
  if (isNaN(port)) throw Error(`port must be a number: ${port}`);
  if (!isAlphanumeric(peerId))
    throw Error(`peerId must be alphanumeric: ${peerId}`);

  if (staticIp) return `/ip4/${staticIp}/tcp/${port}/p2p/${peerId}`;
  if (domain) return `/dns4/${domain}/tcp/${port}/p2p/${peerId}`;
  throw Error(`staticIp or domain must be defined`);
}

/**
 * Strictly validate multiaddresses generated by the IPFS pinner DNP
 * @param multiaddress "/ip4/172.19.0.2/tcp/9096/p2p/12D3KooWK3tVkERcMXqqikhaZhSNoXdSs4M5w6bMEtJomav3VFHX";
 */
export function validateBootstrapMultiaddress(multiaddress: string): string {
  // 0: ""
  // 1: "ip4"
  // 2: "172.19.0.2"
  // 3: "tcp"
  // 4: "9096"
  // 5: "p2p"
  // 6: "12D3KooWK3tVkERcMXqqikhaZhSNoXdSs4M5w6bMEtJomav3VFHX"
  const [
    start,
    ip4OrDns4,
    ipOrDomain,
    portProtocol,
    port,
    p2p,
    peerId
  ] = multiaddress.split("/");
  // 0: ""
  if (start !== "")
    throw Error(`Multiaddress must start by "/": ${multiaddress}`);
  // 1: "ip4" + 2: "172.19.0.2"

  if (ip4OrDns4 === "ip4") {
    if (!isIp4(ipOrDomain)) throw Error(`Invalid ip4 ${ipOrDomain}`);
  } else if (ip4OrDns4 === "dns4") {
    if (!isDomain(ipOrDomain)) throw Error(`Invalid dns4 ${ipOrDomain}`);
  } else {
    throw Error(`First protocol must be ip4 or dns4: ${ip4OrDns4}`);
  }
  // 3: "tcp"
  if (portProtocol !== "tcp")
    throw Error(`portProtocol must be tcp: ${ip4OrDns4}`);
  // 4: "9096"
  if (isNaN(parseInt(port))) throw Error(`port must be a number: ${port}`);
  // 5: "p2p"
  if (p2p !== "p2p") throw Error(`Second protocol must be p2p: ${p2p}`);
  // 6: "12D3KooWK3tVkERcMXqqikhaZhSNoXdSs4M5w6bMEtJomav3VFHX"
  if (!isAlphanumeric(peerId))
    throw Error(`peerId must be alphanumeric: ${peerId}`);

  return `/${ip4OrDns4}/${ipOrDomain}/tcp/${port}/p2p/${peerId}`;
}

/**
 * Returns the last part of a multiaddress, which is the peerId
 * @param multiaddress "/ip4/172.19.0.2/tcp/9096/p2p/12D3KooWK3tVkERcMXqqikhaZhSNoXdSs4M5w6bMEtJomav3VFHX";
 * @return peerId "12D3KooWK3tVkERcMXqqikhaZhSNoXdSs4M5w6bMEtJomav3VFHX"
 */
export function parsePeerIdFromMultiaddress(multiaddress: string): string {
  return multiaddress
    .replace(/\/+$/, "")
    .split("/")
    .slice(-1)[0];
}

function isAlphanumeric(data: string): boolean {
  return /^[a-zA-Z0-9]+$/.test(data);
}

function isIp4(ip4: string): boolean {
  return /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(ip4);
}

function isDomain(domain: string): boolean {
  return /^(?!:\/\/)([a-zA-Z0-9-_]+\.)*[a-zA-Z0-9][a-zA-Z0-9-_]+\.[a-zA-Z]{2,11}?$/.test(
    domain
  );
}
